# predicting-mental-health
This script is a comprehensive chatbot for mood prediction and personalized recommendations. It integrates machine learning to understand user activities, processes natural language to clean input data, and leverages a pretrained model to predict moods accurately.

One unique feature is its ability to provide culturally relevant recommendations by translating suggestions into the user's preferred language. The admin tools make it easy to analyze user patterns and improve the system over time. By combining AI and user interaction, this solution offers a scalable approach to mental health support.

# SETUP INSTRUCTIONS:

Install Required Libraries:

Use the following command to install dependencies:

pip install torch transformers pandas nltk googletrans==4.0.0-rc1 matplotlib seaborn

Download NLTK Data:

The script downloads necessary NLTK resources (wordnet and stopwords) during execution. Ensure an internet connection for the first run:

nltk.download('wordnet')
nltk.download('stopwords')

Prepare the Dataset:

Ensure the mentalhealth.csv file is available in the correct location with the following columns:
activity: Activities performed by users.
mood: Moods corresponding to activities.
recommendation: Recommendations associated with the mood.

Pretrained Model:

The script uses a pretrained Hugging Face model. Install the required model dependencies and verify compatibility:

from transformers import AutoTokenizer, AutoModelForSequenceClassification

tokenizer = AutoTokenizer.from_pretrained("meta-llama/Llama-3.2-1B")

model = AutoModelForSequenceClassification.from_pretrained("meta-llama/Llama-3.2-1B")

Run the Chatbot:

Execute the script in a Python environment to interact with the chatbot. User data will be saved in user_data.csv.
Admin Features:

The admin menu provides insights and visualizations. Ensure the user_data.csv file is populated to access these features.

Admin Menu:

The admin menu provides tools for analyzing user data and generating insights. Here's how it works:

Mood Distribution Pie Chart:

Visualizes the percentage of each mood recorded in the user data.

Activity Time Distribution:

Shows the distribution of user activities across hours of the day.

User Profile Insights:

Allows the admin to view mood trends and interaction details for individual users.
Provides a line plot showing how a user's mood changes over time.

AI-Generated Recommendations:

Displays all recommendations generated by the chatbot, allowing admins to monitor suggestions for relevance and quality.
These tools help the admin understand user patterns, identify trends, and refine the chatbot experience.

Interactive Chatbot

The chatbot handles real-time interaction with users. Key functionalities include:

Accepting user inputs (ID, activity, time, language, etc.).
Predicting user moods based on activities using the dataset or AI model.
Translating recommendations into the user’s preferred language.
Logging all interactions into a CSV file (user_data.csv) for future analysis.

# EXPLANATIONS FOR MY CODE WITH COMMENTS:

# Import necessary libraries

import os  # For file operations

import torch  # For working with models and tensors

from transformers import pipeline, AutoTokenizer, AutoModelForSequenceClassification  # For NLP model

import pandas as pd  # For data manipulation

import nltk  # For text preprocessing

from nltk.corpus import stopwords  # For removing common stop words

from nltk.stem import WordNetLemmatizer  # For reducing words to their base form

import random  # For random selection

from difflib import get_close_matches  # For finding similar strings

from googletrans import Translator  # For text translation

import matplotlib.pyplot as plt  # For plotting

import seaborn as sns  # For enhanced plotting

import os
Used for file operations, such as checking the existence of files or creating new files.

import torch
A core library for machine learning that supports model handling, GPU acceleration, and tensor operations.

from transformers import
Provides tools for handling NLP models. Specifically
pipeline for High-level wrapper for NLP tasks like text classification.
AutoTokenizer and AutoModelForSequenceClassification: Automatically load tokenizers and models for text processing.

import pandas as pd
For data manipulation and analysis, like working with CSV files.

import nltk 
A natural language toolkit for preprocessing tasks, such as tokenization, stopword removal, and lemmatization.

from nltk.corpus ...
Used for text cleaning:
stopwords: List of common words (e.g., "the", "is") that are filtered out in preprocessing.

import random
For generating random choices, such as picking a recommendation.

from difflib ...
get_close_matches: Finds similar strings to a given input, useful for matching activities.

from googletrans ...
Translator: Translates text into different languages for multilingual support.

import matplotlib.pyplot ...
matplotlib: For creating visualizations like charts and graphs.

import seaborn as sns
Enhances the aesthetic of plots generated by matplotlib.

# Download necessary NLTK resources

nltk.download('wordnet')  # WordNet lemmatizer resource

nltk.download('stopwords')  # Stopwords list

nltk.download('wordnet')
Downloads the WordNet lemmatizer, which helps in reducing words to their base form (e.g., "running" → "run").

nltk.download('stopwords')
Downloads a list of common stopwords to filter out irrelevant words during text preprocessing.

# Initialize tools for text preprocessing and translation

stop_words = set(stopwords.words('english'))  # Set of English stop words

lemmatizer = WordNetLemmatizer()  # Tool for lemmatizing text

translator = Translator()  # Translator for multilingual support

stop_words = set(...)
Converts the list of stopwords into a set for faster lookups when filtering out words.

lemmatizer = WordNetLemmatizer()
Initializes a tool for lemmatizing text, reducing words to their dictionary form.

translator = Translator()
Initializes the translator for multilingual recommendations.

# Load dataset containing user activities and moods

csv_path = "/content/mentalhealth.csv"

df = pd.read_csv(csv_path)

csv_path = ... and df = pd.read_csv(...)
Loads the dataset (mentalhealth.csv) containing columns like "activity," "mood," and "recommendation."

# Load the language model and tokenizer for emotion classification

model_id = "meta-llama/Llama-3.2-1B"  # Model identifier

tokenizer = AutoTokenizer.from_pretrained(model_id)

model = AutoModelForSequenceClassification.from_pretrained(model_id)

pipe = pipeline("text-classification", model=model, tokenizer=tokenizer, device=0 if torch.cuda.is_available() else -1)

Load Model and Tokenizer
Model and Tokenizer Setup
model_id specifies the model to be loaded.
tokenizer tokenizes input text for the model.
model handles emotion classification using the loaded model.
pipe simplifies the workflow for classifying text.

# Function to preprocess text: lowercasing, removing stopwords, and lemmatizing

def preprocess_text(text):

    text = str(text).lower()  # Convert text to lowercase
    
    words = [lemmatizer.lemmatize(word) for word in text.split() if word not in stop_words]  # Remove stopwords and lemmatize
    
    return " ".join(words)

Preprocessing Function (preprocess_text)
Converts text to lowercase, removes stopwords, and lemmatizes words. This standardizes the text for model input and matching.

df['processed_activity']
Adds a new column to the dataset with preprocessed activities for easier matching and analysis.

# Define a mapping of model labels to emotions

emotion_mapping = {

    "LABEL_0": "happy",
    
    "LABEL_1": "stressed",
    
    "LABEL_2": "sad",
    
    "LABEL_3": "anxious",
    
    "LABEL_4": "angry",
    
    "LABEL_5": "joy",

emotion_mapping
Maps model labels (e.g., LABEL_0) to human-readable emotions (e.g., "happy").

# Match user-provided activity with activities in the dataset

def match_activity_with_dataset(user_activity):

    preprocessed_activity = preprocess_text(user_activity)
    
    activities = df['processed_activity'].tolist()
    
    matches = get_close_matches(preprocessed_activity, activities, n=1, cutoff=0.6)  # Find closest match
    
    if matches:
    
        matched_row = df[df['processed_activity'] == matches[0]].iloc[0]
        
        return matched_row['mood'], matched_row['recommendation']
        
    return None, None

match_activity_with_dataset
Finds the closest matching activity from the dataset using:
Preprocessed activity for better text matching.
get_close_matches for identifying similar strings.

# Generate a random recommendation for a given mood

def generate_recommendation(predicted_mood):

    filtered_df = df[df['mood'].str.lower() == predicted_mood.lower()]
    
    if not filtered_df.empty:
    
        recommendation = random.choice(filtered_df['recommendation'].tolist())
        
        return recommendation
        
    else:
    
        return "Take care of yourself and try something relaxing!"

generate_recommendation
Filters the dataset by mood and selects a random recommendation for the predicted or matched mood.

# Predict mood based on activity and generate a response
def predict_mood_and_recommendation(activity, date, time, user_name, target_language="en"):

    matched_mood, matched_recommendation = match_activity_with_dataset(activity)
    
    if matched_mood:
    
        # Use dataset match if available
        
        translated_recommendation = translate_recommendation(matched_recommendation, target_language)
        
        response = (
        
            f"Based on your activity at {time} on {date}:\n"
            
            f"- User Name: {user_name}\n"
            
            f"- Matched Mood: {matched_mood}\n"
            
            f"- Recommendation: {translated_recommendation}"
            
        )
        
    else:
    
        # Predict mood using the model
        
        processed_activity = preprocess_text(activity)
        
        result = pipe(processed_activity)
        
        predicted_label = result[0]['label']
        
        predicted_mood = emotion_mapping.get(predicted_label, "joy")

predict_mood_and_recommendation
Combines all major functionalities:
Matches user activity with the dataset.
Predicts mood using the model if no match is found.
Generates a recommendation.
Translates the recommendation and prepares a chatbot response.

# Save user data to a CSV file

user_data_file = "user_data.csv"

if not os.path.exists(user_data_file):

    pd.DataFrame(columns=["User ID", "User Name", "Activity", "Date", "Time", "Language", "Matched Mood", "Recommendation"]).to_csv(user_data_file, index=False)

user_data_file and File Initialization
Ensures that the file for saving user data exists, and initializes it with headers if it doesn’t.

save_user_data
Appends user activity, mood, and recommendation to the user_data.csv file for future analysis.

# Visualization Functions

def load_user_data():

    return pd.read_csv(user_data_file)

def visualize_mood_distribution_pie_chart():

    df = load_user_data()
    
    mood_counts = df["Matched Mood"].value_counts()

    plt.figure(figsize=(8, 8))
    
    plt.pie(

        mood_counts.values,
        
        labels=mood_counts.index,
        
        autopct='%1.1f%%',
        
        startangle=140,
        
        colors=sns.color_palette("pastel")[0:len(mood_counts)]
        
    )
    
    plt.title("Mood Distribution", fontsize=16)
    
    plt.show()
    

def visualize_activity_time():

    df = load_user_data()
    
    df['Time'] = pd.to_datetime(df['Time'], format='%H:%M').dt.hour
    

    plt.figure(figsize=(10, 6))
    
    sns.histplot(df['Time'], bins=24, kde=False, color='blue')
    
    plt.title("Activity Time Distribution", fontsize=16)
    
    plt.xlabel("Hour of the Day", fontsize=12)
    
    plt.ylabel("Number of Activities", fontsize=12)
    
    plt.xticks(range(0, 24, 2))
    
    plt.show()

def view_user_profiles_and_mood_patterns():

    user_data_path = "user_data.csv"

    if os.path.exists(user_data_path):
    
        user_data = pd.read_csv(user_data_path)
        
    else:
    
        print("No data available.")
        
        return

    user_id = input("Enter User ID to view profile: ").strip()
    
    user_data["User ID"] = user_data["User ID"].astype(str)
    
    user_profile = user_data[user_data["User ID"] == user_id]

    if user_profile.empty:
    
        print(f"No data found for User ID: {user_id}")
        
    else:
    
        print(f"Profile for User ID: {user_id}")
        
        print(f"Total Interactions: {len(user_profile)}")
        

        user_profile["DateTime"] = pd.to_datetime(user_profile["Date"] + " " + user_profile["Time"])
        
        user_profile.sort_values(by="DateTime", inplace=True)

        sns.lineplot(
        
            data=user_profile,

            x="DateTime",
            
            y=user_profile["Matched Mood"].rank(method="dense"),
            
            hue="Matched Mood",

            
            marker="o",
        )

        plt.title("Mood Trend Over Time")
        
        plt.xticks(rotation=45)
        
        plt.tight_layout()
        
        plt.show()

def display_ai_generated_recommendations():

    print("\nAI-Generated Recommendations:")
    
    try:
    
        user_data = load_user_data()
        
        if user_data.empty:
        
            print("No data available.")
            
        else:
        
            for idx, row in user_data.iterrows():
            
                print(f"- User ID: {row['User ID']} | Recommendation: {row['Recommendation']}")
                
    except Exception as e:
    
        print(f"Error loading data: {e}")
        
Visualization Functions
These functions are used to generate graphical insights into user mood trends and activity data.

1. Mood Distribution Pie Chart
Function: visualize_mood_distribution_pie_chart()

Purpose:
This function creates a pie chart to visualize the distribution of moods across all users. It shows the proportion of each mood (e.g., happy, stressed, anxious).

Steps:

Load User Data:
Reads the user data from user_data.csv using load_user_data().

Count Mood Frequencies:
Uses value_counts() to count how many times each mood appears in the data.

Plot Pie Chart:

plt.pie() is used to create the pie chart.
Mood counts (mood_counts.values) determine the sizes of the slices.
Mood labels (mood_counts.index) are added as labels.
autopct='%1.1f%%' displays percentages.
Colors are selected using sns.color_palette("pastel").
Show Chart:

plt.title() sets the chart title as "Mood Distribution."
plt.show() displays the chart.
Use Case:
The administrator can quickly see which moods are most or least common among users.
![mood dist](https://github.com/user-attachments/assets/32d3808c-a26c-403c-8767-e14c145b1f66)



2. Activity Time Distribution
Function: visualize_activity_time()

Purpose:
This function visualizes when users are most active by plotting the distribution of activity times (hours of the day).

Steps:

Load User Data:
Reads user_data.csv to fetch user activity times.

Convert Time to Hours:
Converts the Time column to 24-hour format using pd.to_datetime(), extracting only the hour component.

Plot Histogram:

sns.histplot() generates a bar plot of activity counts for each hour.
The data is grouped into 24 bins (for 24 hours).
plt.title() sets the title as "Activity Time Distribution."
plt.xlabel() and plt.ylabel() label the axes.
plt.xticks(range(0, 24, 2)) ensures x-axis ticks show every two hours.
Show Plot:
Displays the histogram using plt.show().

Use Case:
Helps identify peak hours for user activities, useful for scheduling interventions or recommendations.
![activity time](https://github.com/user-attachments/assets/a31c8702-bffe-4c85-b34f-637e648f07d8)



3. Mood Trends for a Specific User
Function: view_user_profiles_and_mood_patterns()

Purpose:
This function lets an admin view the mood trends and interaction history for a specific user. It includes:

Mood counts over time.
A line plot showing mood changes across dates and times.

Steps:
Load Data for a Specific User:
Prompts the admin for a user ID.
Filters user_data.csv for rows matching the given user ID.
![personal profile](https://github.com/user-attachments/assets/fe6fb191-3105-4782-93d6-48da035a5b29)

4. Purpose of display_ai_generated_recommendations():
The function display_ai_generated_recommendations() is designed to display AI-generated recommendations stored in the user data file (user_data.csv). It retrieves the data and formats it for easy reading by listing each user’s recommendation alongside their user ID.
![display AI generated recommendation](https://github.com/user-attachments/assets/8eeaa0eb-9006-4190-ae82-909b04d4d7fe)



Summarize Data:
Displays basic statistics, like total interactions and mood frequencies.

Prepare for Trend Plotting:
Combines Date and Time into a single DateTime column.
Sorts the data by DateTime to maintain chronological order.
Plot Mood Trends:

sns.lineplot() plots moods as a line graph.
rank(method='dense') assigns an ordinal value to each mood for plotting.
Different moods are displayed in different colors using the hue parameter.

Show Plot:

Adds titles, axis labels, and a legend.
Rotates x-axis labels to make dates and times readable.

Use Case:
Admins can monitor mood swings and patterns for a user, potentially identifying times of distress or improvement.
How These Visualizations are Used in the Admin Menu

Function: admin_menu()
Offers the following options for visualization:
View mood distribution as a pie chart.
Analyze activity times as a histogram.
View recommendations generated by the AI.
Explore user mood trends through line plots.
Calls the respective visualization function based on user choice.

# Main function to interact with the chatbot

def get_user_input():

    print("Chatbot: Hello! Please provide your details. (Type 'exit' to quit)")
    
    while True:
    
        user_id = input("User ID: ")
        
        if user_id.lower() == 'exit':
        
            print("Goodbye!")
            
            break
            
        user_name = input("User Name: ")
        
        if user_name.lower() == 'exit':
        
            break
            
        activity = input("Activity: ")
        
        date = input("Date: ")
        
        time = input("Time: ")
        
        language = input("Language: ").strip().lower()
        
        response, mood, recommendation = predict_mood_and_recommendation(activity, date, time, user_name, target_language=language)
        
        print(response)
        
        save_user_data(user_id, user_name, activity, date, time, language, mood, recommendation)

get_user_input
The main chatbot function:
Prompts the user for input (e.g., activity, date, language).
Predicts mood and provides recommendations.
Saves the user’s data for future analysis.

# Start the chatbot

get_user_input()

Chatbot Starts
Runs the get_user_input() function to begin the chatbot interaction. Users can provide input to get mood predictions and recommendations.

# THANK YOU
